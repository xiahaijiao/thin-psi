//
//  RAPSIUtilOpenSSL.cpp
//  RASoftAlg
//
//  Created by john on 2020/6/11.
//  Copyright © 2020 China rongan. All rights reserved.
//

#include "RAPSIUtilOpenSSL.hpp"

#include <openssl/bn.h>
#include <openssl/rand.h>
#include <openssl/err.h>
#include <openssl/ec.h>
#include <openssl/obj_mac.h>
#include <stdint.h>
#include <openssl/ossl_typ.h>
#include <openssl/evp.h>
#include "string.h"
#include <openssl/rsa.h>
#include <iostream>
#include<string.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <fstream>

void genAddr();
void findAddr2();
void findAddr();
void genAddrRipple();
//char* en_base58(unsigned char* input)
char* de_base58(char* src);
int base58decode(const std::string input, int len, unsigned char* result);
int base58encode(const std::string input, int len, unsigned char result[]);
void findAddrThread();
void genRandom(char* res);
void getPubBase(char* priStr, char* baseG, char* pubStr);
using namespace std;
void testBtc2();
void test_next_y();


//文件入口函数
void bntest() {

	// cout << "bntest  文件入口函数" << endl;
	//testBNArithmetic2();
	//testAddress();

	//sha256();
	//genAddr();
	//findAddr();

	//精简pub
	//indAddr2();
//	testRipple();
	//testAddress();
	//查找附近点
	//testBtc2();
	test_next_y();

	//findAddr();
	//testBNArithmetic();
	//call1();

}

struct CurveParams {
	BIGNUM* p;
	BIGNUM* a;
	BIGNUM* b;
	EC_GROUP* group;
	EC_POINT* G;
	BIGNUM* order;

};
typedef struct CurveParams CurveParams;

CurveParams* g_curve_params;


#define DOMAIN_CHECK(c) ('0'<=(c)&&(c)<='9'||'a'<=(c)&&(c)<='f'||'A'<=(c)&&(c)<='F')


#define BASE58TABLE "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
#include <openssl/sha.h>

std::string base58encode(const std::string& hexstring);

void hashSha256(unsigned char* puchMM, size_t uiMMLen, unsigned char* outEChar, unsigned  int* uiDigestLen) {
	//const EVP_MD* EVP_sha256(void);
	//const EVP_MD* EVP_ripemd160(void);

	const EVP_MD* mdType = EVP_sha256();
	EVP_MD_CTX* ctx_evp = EVP_MD_CTX_new();
	//         EVP_MD_CTX_init(ctx_evp);
	EVP_DigestInit_ex(ctx_evp, mdType, NULL);
	EVP_DigestUpdate(ctx_evp, puchMM, uiMMLen);
	EVP_DigestFinal_ex(ctx_evp, outEChar, uiDigestLen);
	EVP_MD_CTX_free(ctx_evp);


}


void hashripe160(unsigned char* puchMM, size_t uiMMLen, unsigned char* outEChar, unsigned  int* uiDigestLen) {


	const EVP_MD* mdType = EVP_ripemd160();
	EVP_MD_CTX* ctx_evp = EVP_MD_CTX_new();
	//         EVP_MD_CTX_init(ctx_evp);
	EVP_DigestInit_ex(ctx_evp, mdType, NULL);
	EVP_DigestUpdate(ctx_evp, puchMM, uiMMLen);
	EVP_DigestFinal_ex(ctx_evp, outEChar, uiDigestLen);
	EVP_MD_CTX_free(ctx_evp);


}


void raHashSha256(char* plain, int len, char* hash) {

	//    unsigned char *puchMM = malloc(sizeof(len+1));
	unsigned char* puchMM = (unsigned char*)malloc(len + 1);
	//void convertStrToUnChar(char* str, unsigned char* UnChar)
	convertStrToUnChar(plain, puchMM);
	//memcpy(puchMM, plain, len);
	unsigned char* outEchar = (unsigned char*)malloc(32 + 1);
	unsigned int outLen = 32;

	hashSha256(puchMM, len, outEchar, &outLen);

	char* outHash = (char*)malloc(64 + 1);
	memset(outHash, 0, 64 + 1);
	//    memcpy(outHash, outEchar, outLen);
	convertUnCharToStr(outHash, outEchar, outLen);
	strcpy(hash, outHash);

	//    unsigned char tmp[33] = {0};
	//    convertStrToUnChar(hash, tmp);

	//清理敏感数据
	memset(puchMM, 0, len);
	//strcpy(plain, "");

	free(puchMM);
	free(outEchar);
	free(outHash);

}


void raHashRipe160(char* plain, int len, char* hash) {

	//    unsigned char *puchMM = malloc(sizeof(len+1));
	unsigned char* puchMM = (unsigned char*)malloc(len + 1);
	//void convertStrToUnChar(char* str, unsigned char* UnChar)
	convertStrToUnChar(plain, puchMM);
	//memcpy(puchMM, plain, len);
	unsigned char* outEchar = (unsigned char*)malloc(32 + 1);
	unsigned int outLen = 32;

	hashripe160(puchMM, len, outEchar, &outLen);
	//20
	//cout << outLen << endl;

	char* outHash = (char*)malloc(64 + 1);
	memset(outHash, 0, 64 + 1);
	//    memcpy(outHash, outEchar, outLen);
	convertUnCharToStr(outHash, outEchar, outLen);
	strcpy(hash, outHash);

	//    unsigned char tmp[33] = {0};
	//    convertStrToUnChar(hash, tmp);

	//清理敏感数据
	memset(puchMM, 0, len);
	//strcpy(plain, "");

	free(puchMM);
	free(outEchar);
	free(outHash);

}

void sha256() {


	char s_buf[] = "0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6";
	char d_buf[10000];
	int s_len = strlen(s_buf);
	int d_len = 10000;
	//600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408
	//raHashSha256(s_buf, strlen(s_buf)/2,d_buf);

	char s_buf2[] = "600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408";
	//010966776006953D5567439E5E39F86A0D273BEE
	raHashRipe160(s_buf2, strlen(s_buf2) / 2, d_buf);


	cout << d_buf << endl;
}
void genAddr() {
	/*
	2.公钥
	3.sha256
	4..ripe160
	5.加版本
	6.sha256
	7.sha256
	8.后四位拼接到第5步之后
	9.base58编码
	*/
	//char* pubStr = "0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6";
	//char* pubStr = "0250863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352";
	char pubStr[256] = { 0 };
	cout << "pubstr:" << endl;
	cin >> pubStr;
	//char step3[100] = { 0 };
	cout << pubStr << endl;
	char step3[100] = { 0 };
	//char* step3 =(char*) malloc(1024);
	raHashSha256(pubStr, strlen(pubStr) / 2, step3);
	cout << "step3:" << step3 << endl;


	char Ripe160_step4[100] = { 0 };
	raHashRipe160(step3, strlen(step3) / 2, Ripe160_step4);

	cout << "step4:" << Ripe160_step4 << endl;

	char version_step5[100] = { 0 };
	sprintf(version_step5, "00%s", Ripe160_step4);
	cout << "step5:" << version_step5 << endl;

	char step6[100] = { 0 };
	raHashSha256(version_step5, strlen(version_step5) / 2, step6);
	cout << "step6:" << step6 << endl;

	char step7[100] = { 0 };

	raHashSha256(step6, strlen(step6) / 2, step7);
	cout << "step7:" << step7 << endl;

	char step8[100] = { 0 };
	char last4[10] = { 0 };
	//strncpy(last4, step7+ strlen(step7)-8, 8); 
	strncpy(last4, step7, 8);
	sprintf(step8, "%s%s", version_step5, last4);
	cout << "step8:" << step8 << endl;


	string hex_string = step8;

	//const char* step9 =  base58encode(hex_string).c_str();  //c_str()
	char step9[100] = { 0 };
	sprintf(step9, "%s", base58encode(hex_string).c_str());
	cout << "step9:" << base58encode(hex_string).c_str() << endl;
	cout << "step9:" << step9 << endl;


}


void genAddr2(char* pubStr, char* addrStr) {
	/*
	2.公钥
	3.sha256
	4..ripe160
	5.加版本
	6.sha256
	7.sha256
	8.后四位拼接到第5步之后
	9.base58编码
	*/
	//char* pubStr = "0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6";
	//char* pubStr = "0250863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352";

	char step3[100] = { 0 };
	//char* step3 =(char*) malloc(1024);
	raHashSha256(pubStr, strlen(pubStr) / 2, step3);


	char Ripe160_step4[100] = { 0 };
	raHashRipe160(step3, strlen(step3) / 2, Ripe160_step4);

	char version_step5[100] = { 0 };
	sprintf(version_step5, "00%s", Ripe160_step4);

	char step6[100] = { 0 };
	raHashSha256(version_step5, strlen(version_step5) / 2, step6);

	char step7[100] = { 0 };

	raHashSha256(step6, strlen(step6) / 2, step7);

	char step8[100] = { 0 };
	char last4[10] = { 0 };
	//strncpy(last4, step7+ strlen(step7)-8, 8); 
	strncpy(last4, step7, 8);
	sprintf(step8, "%s%s", version_step5, last4);


	string hex_string = step8;

	//const char* step9 =  base58encode(hex_string).c_str();  //c_str()
	char step9[100] = { 0 };
	sprintf(step9, "%s", base58encode(hex_string).c_str());
	//strcpy(addrStr, step9);
	strcpy(addrStr, step9);

}

void getPubBase(char* priStr, char* baseG, char* pubStr) {

	int ret;	BN_CTX* ctx = BN_CTX_new();

	BIGNUM* bn_n = BN_new();
	ret = BN_hex2bn(&bn_n, priStr);
	EC_POINT* ec_r = EC_POINT_new(g_curve_params->group);

	//EC_POINT* EC_POINT_hex2point(const EC_GROUP * group, const char* hex,
	//	EC_POINT * p, BN_CTX * ctx);

	EC_POINT* ec_base = EC_POINT_new(g_curve_params->group);
	EC_POINT_hex2point(g_curve_params->group, baseG, ec_base, ctx);



	//Q0 = k0 * P
	ret = EC_POINT_mul(g_curve_params->group, ec_r, NULL, ec_base, bn_n, ctx);
	//ret = EC_POINT_mul(g_curve_params->group, ec_r, NULL, g_curve_params->G, bn_n, ctx);

	char* result_invert = EC_POINT_point2hex(g_curve_params->group, ec_r, POINT_CONVERSION_COMPRESSED, ctx);
	//cout << result_invert << endl;
	strcpy(pubStr, result_invert);


	BN_CTX_free(ctx);
	BN_free(bn_n);
	EC_POINT_free(ec_r);
	EC_POINT_free(ec_base);
	OPENSSL_free(result_invert);




}

void getPubBaseQ_mp(char* Q_str,char*mp_str,char*pubStr){

int ret;	BN_CTX* ctx = BN_CTX_new();

	EC_POINT* ec_r = EC_POINT_new(g_curve_params->group);

	//EC_POINT* EC_POINT_hex2point(const EC_GROUP * group, const char* hex,
	//	EC_POINT * p, BN_CTX * ctx);

	EC_POINT* Q = EC_POINT_new(g_curve_params->group);
	EC_POINT* mp = EC_POINT_new(g_curve_params->group);
	EC_POINT_hex2point(g_curve_params->group, Q_str, Q, ctx);
	EC_POINT_hex2point(g_curve_params->group, mp_str, mp, ctx);



 // inverse of the supplied point a
 //        int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx);
// 		a+b=r		
 // int EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
 //                         const EC_POINT *b, BN_CTX *ctx);

EC_POINT_invert(g_curve_params->group, mp, ctx);
EC_POINT_add(g_curve_params->group,ec_r, Q,mp, ctx);

	char* result_invert = EC_POINT_point2hex(g_curve_params->group, ec_r, POINT_CONVERSION_COMPRESSED, ctx);
	char* mp_inverse = EC_POINT_point2hex(g_curve_params->group, mp, POINT_CONVERSION_COMPRESSED, ctx);
	char* Q_temp = EC_POINT_point2hex(g_curve_params->group, Q, POINT_CONVERSION_COMPRESSED, ctx);

	// cout<<"mp origin: "<<mp_str<<endl;
	// cout<<"mp_inverse: "<<mp_inverse<<endl;
	// cout<<"Q before: "<<Q_str<<endl;
	// cout<<"Q after: "<<Q_temp<<endl;

	//cout << result_invert << endl;
	strcpy(pubStr, result_invert);


	BN_CTX_free(ctx);
	
	EC_POINT_free(ec_r);
	EC_POINT_free(Q);
	EC_POINT_free(mp);
	
	OPENSSL_free(result_invert);
	OPENSSL_free(mp_inverse);
	OPENSSL_free(Q_temp);




}
void getPub(char* priStr, char* pubStr) {

	int ret;	BN_CTX* ctx = BN_CTX_new();

	BIGNUM* bn_n = BN_new();
	ret = BN_hex2bn(&bn_n, priStr);
	EC_POINT* ec_r = EC_POINT_new(g_curve_params->group);


	//Q0 = k0 * P
	ret = EC_POINT_mul(g_curve_params->group, ec_r, NULL, g_curve_params->G, bn_n, ctx);

	char* result_invert = EC_POINT_point2hex(g_curve_params->group, ec_r, POINT_CONVERSION_COMPRESSED, ctx);
	//cout << result_invert << endl;
	strcpy(pubStr, result_invert);


	BN_CTX_free(ctx);
	BN_free(bn_n);
	EC_POINT_free(ec_r);
	OPENSSL_free(result_invert);




}
void addBn(char* a, char* b, char* r) {
	int ret;	BN_CTX* ctx = BN_CTX_new();

	BIGNUM* bn_a = BN_new();
	BIGNUM* bn_b = BN_new();
	BIGNUM* bn_r = BN_new();
	ret = BN_hex2bn(&bn_a, a);
	ret = BN_hex2bn(&bn_b, b);
	ret = BN_hex2bn(&bn_r, r);
	ret = BN_add(bn_r, bn_a, bn_b);
	//char* BN_bn2hex(const BIGNUM * a);

	char* res = BN_bn2hex(bn_r);
	//BN_add(BIGNUM * r, const BIGNUM * a, const BIGNUM * b);

	strcpy(r, res);



	BN_CTX_free(ctx);
	BN_free(bn_a);
	BN_free(bn_b);
	BN_free(bn_r);

	OPENSSL_free(res);




}
void findAddr() {
	//char* startX = "f99d00000000";
	char startX[100] = { 0 };
	//cout << "startX f99d000000000000 (f99d 0000 ,0000 0000)" << endl;
	cout << "startX 0000000000000000 (f99d 0000 ,0000 0000)" << endl;
	cin >> startX;
	//LONG_MAX
		//ULONG_MAX
	unsigned long index = 0;
	unsigned long count = ULONG_MAX; //0xffff ffffUL
	//unsigned int count = UINT_MAX;


	while (true)
	{
		if (index > count)
		{
			break;
		}

		char indexStr[100] = { 0 };
		//sprintf(indexStr, "%lx | %lx",index,count);
		sprintf(indexStr, "%lx", index);
		//cout << indexStr << endl;

		//cout << index << "," << count << endl;
		//char* priStr = "f9a9013bd8be";
		char priStr[100] = { 0 };

		addBn(startX, indexStr, priStr);
		char pubStr[256] = { 0 };
		getPub(priStr, pubStr);
		char addrStr[256] = { 0 };

		genAddr2(pubStr, addrStr);


		cout << priStr << "|	" << addrStr << "|	" << indexStr << "|	" << pubStr << endl;
		if (strcmp(addrStr, "16jY7qLJnxb7CHZyqBP8qca9d51gAjyXQN") == 0)
		{
			cout << "find addr:" << addrStr << endl;
			break;
		}
		index++;
	}
}


void findAddr2() {
	//char* startX = "f99d00000000";
	char startX[100] = { 0 };
	//cout << "startX f99d000000000000 (f99d 0000 ,0000 0000)" << endl;
	//cout << "startX 0000000000000000 (  f99cbdfb599ed010  ,0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 );startX" << endl;
	cout << "startX:" << endl;
	cin >> startX;
	cout << "baseG:" << endl;
	char baseG[100] = { 0 };
	cin >> baseG;

	//LONG_MAX
		//ULONG_MAX
	unsigned long index = 0;
	unsigned long count = ULONG_MAX; //0xffff ffffUL
	//unsigned int count = UINT_MAX;
	int isRandom = 0;
	cout << "is random 1(random) 0 (not random)" << endl;
	cin >> isRandom;
	// srand((unsigned)1);
	srand((unsigned)time(NULL));
	cout << "baseG: " << baseG << " ,isRandom:" << isRandom << ",startX:" << startX << endl;
	while (true)
	{
		if (index > count)
		{
			break;
		}

		char indexStr[100] = { 0 };
		//sprintf(indexStr, "%lx | %lx",index,count);
		sprintf(indexStr, "%lx", index);
		//cout << indexStr << endl;

		//cout << index << "," << count << endl;
		//char* priStr = "f9a9013bd8be";
		char priStr[100] = { 0 };
		if (isRandom == 0) {
			addBn(startX, indexStr, priStr);
		}
		else {
			// char* pubStr = (char*)malloc(100);
			genRandom(priStr);

			// cout<<priStr<<endl;
		}
		// addBn(startX, indexStr, priStr);
		char pubStr[256] = { 0 };
		//getPub(priStr, pubStr);
		//getPub(priStr, pubStr);
		getPubBase(priStr, baseG, pubStr);
		char addrStr[256] = { 0 };

		genAddr2(pubStr, addrStr);
		char flag[10] = { 0 };
		char pubX[100] = { 0 };

		strncpy(flag, pubStr, 2);
		strncpy(pubX, pubStr + 2, strlen(pubStr) - 2);

		char targetAddress[] = "16jY7qLJnxb7CHZyqBP8qca9d51gAjyXQN";
		//		if (strncmp(addrStr,targetAddress,3) == 0)
		//		{
		//			cout << priStr << "|" << addrStr << "|" << flag << "|" << pubX << endl;
		//
		if (strcmp(addrStr, "16jY7qLJnxb7CHZyqBP8qca9d51gAjyXQN") == 0)
		{
			cout << "find addr:" << addrStr << endl;
			break;
		}
		//		}
		cout << priStr << "|" << addrStr << "|" << flag << "|" << pubX << endl;
		//cout << priStr << "|" <<flag<<"|"<<pubX << endl;

		index++;
	}
}

void findAddr3() {
	//char* startX = "f99d00000000";
	char startX[100] = { 0 };
	//cout << "startX f99d000000000000 (f99d 0000 ,0000 0000)" << endl;
	cout << "startX 0000000000000000 (  f99cbdfb599ed010  ,0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 );startX" << endl;
	cout << "startX:" << endl;
	cin >> startX;
	cout << "baseG:" << endl;
	char baseG[100] = { 0 };
	cin >> baseG;

	//LONG_MAX
		//ULONG_MAX
	unsigned long index = 0;
	unsigned long count = ULONG_MAX; //0xffff ffffUL
	//unsigned int count = UINT_MAX;
	int isRandom = 0;
	cout << "is random 1(random) 0 (not random)" << endl;
	cin >> isRandom;
	// srand((unsigned)1);
	srand((unsigned)time(NULL));
	cout << "baseG: " << baseG << " ,isRandom:" << isRandom << ",startX:" << startX << endl;
	while (true)
	{
		if (index > count)
		{
			break;
		}

		char indexStr[100] = { 0 };
		//sprintf(indexStr, "%lx | %lx",index,count);
		sprintf(indexStr, "%lx", index);
		//cout << indexStr << endl;

		//cout << index << "," << count << endl;
		//char* priStr = "f9a9013bd8be";
		char priStr[100] = { 0 };
		if (isRandom == 0) {
			addBn(startX, indexStr, priStr);
		}
		else {
			// char* pubStr = (char*)malloc(100);
			genRandom(priStr);

			// cout<<priStr<<endl;
		}
		// addBn(startX, indexStr, priStr);
		char pubStr[256] = { 0 };
		//getPub(priStr, pubStr);
		//getPub(priStr, pubStr);
		getPubBase(priStr, baseG, pubStr);
		char addrStr[256] = { 0 };

		genAddr2(pubStr, addrStr);
		char flag[10] = { 0 };
		char pubX[100] = { 0 };

		strncpy(flag, pubStr, 2);
		strncpy(pubX, pubStr + 2, strlen(pubStr) - 2);

		char targetAddress[] = "16jY7qLJnxb7CHZyqBP8qca9d51gAjyXQN";
		//		if (strncmp(addrStr,targetAddress,3) == 0)
		//		{
		//			cout << priStr << "|" << addrStr << "|" << flag << "|" << pubX << endl;
		//
		if (strcmp(addrStr, "16jY7qLJnxb7CHZyqBP8qca9d51gAjyXQN") == 0)
		{
			cout << "find addr:" << addrStr << endl;
			break;
		}
		//		}
		//cout << priStr << "|" << addrStr << "|" << flag << "|" << pubX << endl;
		//cout << priStr << "|" <<flag<<"|"<<pubX << endl;
		//strncmp()
		int len_cmp = 2;
		if (strncmp(pubX,"0000000000000000000000000000000000000000",len_cmp) == 0) {
			cout << priStr << " " << pubStr << endl;

		}
		index++;
	}
}


bool call1(void)
{
	//string str = "0123456789abcdefghijklmn";
	string str = "00010966776006953D5567439E5E39F86A0D273BEE";

	unsigned char result[32];
	SHA256((const unsigned char*)str.c_str(), str.length(), result);

	for (int i = 0; i < 32; i++) {
		printf("%02x ", result[i]);
	}
	cout << endl;
	return true;
}
std::string base58encode(const std::string& hexstring)
{
	std::string result = "";
	BN_CTX* bnctx = BN_CTX_new();
	BIGNUM* bn = BN_new();
	BIGNUM* bn0 = BN_new();
	BIGNUM* bn58 = BN_new();
	BIGNUM* dv = BN_new();
	BIGNUM* rem = BN_new();

	BN_hex2bn(&bn, hexstring.c_str());
	//printf("bn:%s\n", BN_bn2dec(bn));
	BN_hex2bn(&bn58, "3a");//58
	BN_hex2bn(&bn0, "0");

	while (BN_cmp(bn, bn0) > 0) {
		BN_div(dv, rem, bn, bn58, bnctx);
		BN_copy(bn, dv);
		//printf("dv: %s\n", BN_bn2dec(dv));
		//printf("rem:%s\n", BN_bn2dec(rem));
		char base58char = BASE58TABLE[BN_get_word(rem)];
		result += base58char;
	}

	std::string::iterator pbegin = result.begin();
	std::string::iterator pend = result.end();
	while (pbegin < pend) {
		char c = *pbegin;
		*(pbegin++) = *(--pend);
		*pend = c;
	}
	result.insert(0, 1, '1');



	BN_CTX_free(bnctx);
	BN_free(bn);
	BN_free(bn0);
	BN_free(bn58);
	BN_free(dv);
	BN_free(rem);



	return result;
}
void testAddress() {

	//std::string hex_string = "00010966776006953D5567439E5E39F86A0D273BEED61967F6";
	std::string hex_string = "00010966776006953D5567439E5E39F86A0D273BEED61967F6";
	cout << base58encode(hex_string).c_str() << endl;
}

void hashSM3(unsigned char* puchMM, size_t uiMMLen, unsigned char* outEChar, unsigned  int* uiDigestLen) {
	//const EVP_MD* EVP_sha256(void);
	//const EVP_MD* EVP_ripemd160(void);

	const EVP_MD* mdType = EVP_sm3();
	EVP_MD_CTX* ctx_evp = EVP_MD_CTX_new();
	//         EVP_MD_CTX_init(ctx_evp);
	EVP_DigestInit_ex(ctx_evp, mdType, NULL);
	EVP_DigestUpdate(ctx_evp, puchMM, uiMMLen);
	EVP_DigestFinal_ex(ctx_evp, outEChar, uiDigestLen);
	EVP_MD_CTX_free(ctx_evp);


}


void raHashSM3(char* plain, int len, char* hash) {

	//    unsigned char *puchMM = malloc(sizeof(len+1));
	unsigned char* puchMM = (unsigned char*)malloc(len + 1);

	memcpy(puchMM, plain, len);
	unsigned char* outEchar = (unsigned char*)malloc(32 + 1);
	unsigned int outLen = 32;

	hashSM3(puchMM, len, outEchar, &outLen);

	char* outHash = (char*)malloc(64 + 1);
	memset(outHash, 0, 64 + 1);
	//    memcpy(outHash, outEchar, outLen);
	convertUnCharToStr(outHash, outEchar, outLen);
	strcpy(hash, outHash);

	//    unsigned char tmp[33] = {0};
	//    convertStrToUnChar(hash, tmp);

	//清理敏感数据
	memset(puchMM, 0, len);
	strcpy(plain, "");

	free(puchMM);
	free(outEchar);
	free(outHash);

}
int  setECC(BN_CTX** ctx, EC_GROUP** group, BIGNUM** p, BIGNUM** a, BIGNUM** b, EC_POINT** outG, BIGNUM** outOrder) {


	/*
						###############  开发环境参数

	BN_hex2bn(p, "8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3");
	BN_hex2bn(a, "787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498");
	BN_hex2bn(b, "63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A");
	BN_hex2bn(&order, "8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7");
	BN_hex2bn(&xg, "421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D");
	BN_hex2bn(&yg, "0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2");



	*/

	/*
						#################  生产环境参数

p=FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF
a=FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC
b=28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93

*group = EC_GROUP_new_curve_GFp(*p, *a, *b, *ctx);
	//设置G点
	EC_POINT* G = EC_POINT_new(*group);

	BIGNUM* xg = BN_new();
	BIGNUM* yg = BN_new();
	BIGNUM* order = BN_new();


n=FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123
Gx=32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7
Gy=BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0



	BN_hex2bn(p, "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF");
	BN_hex2bn(a, "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC");
	BN_hex2bn(b, "28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93");

	*group = EC_GROUP_new_curve_GFp(*p, *a, *b, *ctx);
	//设置G点
	EC_POINT* G = EC_POINT_new(*group);

	BIGNUM* xg = BN_new();
	BIGNUM* yg = BN_new();
	BIGNUM* order = BN_new();

	BN_hex2bn(&order, "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123");
	BN_hex2bn(&xg, "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7");
	BN_hex2bn(&yg, "BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0");


	*/

	/*
	Recommended Parameters secp256k1

	p = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
The curve E: y2 = x3 + ax + b over Fp is defined by:

a = 0000000000000000000000000000000000000000000000000000000000000000
b = 0000000000000000000000000000000000000000000000000000000000000007

G = 04
79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8

n = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

h = 01


 y2 = x3 + 130x + 565 defined over F719.

 a = 130  ,82
 b = 565, 235
 p=719,	2cf
 n = 699, 2bb


 P = (107, 443) and that Q = (608, 427),
  P = (6b, 1bb) and that Q = (260, 1ab),


	*/

	//BN_hex2bn(p, "2cf");
	//BN_hex2bn(a, "82");
	//BN_hex2bn(b, "235");

	//*group = EC_GROUP_new_curve_GFp(*p, *a, *b, *ctx);
	////设置G点
	//EC_POINT* G = EC_POINT_new(*group);

	//BIGNUM* xg = BN_new();
	//BIGNUM* yg = BN_new();
	//BIGNUM* order = BN_new();

	//BN_hex2bn(&order, "2bb");
	//BN_hex2bn(&xg, "6b");
	//BN_hex2bn(&yg, "1bb");



	BN_hex2bn(p, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
	BN_hex2bn(a, "0000000000000000000000000000000000000000000000000000000000000000");
	BN_hex2bn(b, "0000000000000000000000000000000000000000000000000000000000000007");

	*group = EC_GROUP_new_curve_GFp(*p, *a, *b, *ctx);
	//设置G点
	EC_POINT* G = EC_POINT_new(*group);

	BIGNUM* xg = BN_new();
	BIGNUM* yg = BN_new();
	BIGNUM* order = BN_new();

	BN_hex2bn(&order, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");


	BN_hex2bn(&xg, "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798");
	BN_hex2bn(&yg, "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");



	char gx[256] = { 0 };
	char gy[256] = { 0 };
	//cout << "输入gx,gy" << endl;
	//cin >> gx;
	//cin >> gy;
	//cout << "gx:" << gx << ",gy:" << gy << endl;
	//BN_hex2bn(&xg, gx);
	//BN_hex2bn(&yg, gy);

	int    iRet = EC_POINT_set_affine_coordinates(*group, G, xg, yg, *ctx);

	BIGNUM* cofactor = BN_new();
	BN_hex2bn(&cofactor, "1");

	iRet = EC_GROUP_set_generator(*group, G, order, cofactor);
	*outG = EC_POINT_new(*group);



	EC_POINT_copy(*outG, G);
	BN_copy(*outOrder, order);

	EC_POINT_free(G);
	BN_free(xg);
	BN_free(yg);
	BN_free(order);
	BN_free(cofactor);





	return iRet;

}

int  setECC3(BN_CTX** ctx, EC_GROUP** group, BIGNUM** p, BIGNUM** a, BIGNUM** b, EC_POINT** outG, BIGNUM** outOrder) {

	cout << "P:" << endl;
	int p_dec, a_dec, b_dec, gx_dec, gy_dec, order_dec;

	p_dec = 43;
	a_dec = 1;
	b_dec = 1;
	gx_dec = 43;
	gy_dec = 33;
	order_dec = 34;
	cin >> p_dec;
	cout << "a:" << endl;
	cin >> a_dec;
	cout << "b:" << endl;
	cin >> b_dec;
	cout << "x:" << endl;
	cin >> gx_dec;
	cout << "y:" << endl;
	cin >> gy_dec;
	cout << "order:" << endl;
	cin >> order_dec;

	char temp[256] = { 0 };
	sprintf(temp, "%x", p_dec);

	BN_hex2bn(p, temp);
	cout << "P:" << temp << endl;
	memset(temp, 0, 256);
	sprintf(temp, "%x", a_dec);
	BN_hex2bn(a, temp);
	cout << "a:" << temp << endl;
	memset(temp, 0, 256);
	sprintf(temp, "%x", b_dec);
	BN_hex2bn(b, temp);
	cout << "b:" << temp << endl;
	memset(temp, 0, 256);
	//BN_hex2bn(p, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
	//BN_hex2bn(a, "0000000000000000000000000000000000000000000000000000000000000000");
	//BN_hex2bn(b, "0000000000000000000000000000000000000000000000000000000000000007");

	*group = EC_GROUP_new_curve_GFp(*p, *a, *b, *ctx);
	//设置G点
	EC_POINT* G = EC_POINT_new(*group);

	BIGNUM* xg = BN_new();
	BIGNUM* yg = BN_new();
	BIGNUM* order = BN_new();

	sprintf(temp, "%x", order_dec);
	BN_hex2bn(&order, temp);
	cout << "order:" << temp << endl;
	memset(temp, 0, 256);

	sprintf(temp, "%x", gx_dec);
	BN_hex2bn(&xg, temp);
	cout << "x:" << temp << endl;
	memset(temp, 0, 256);
	sprintf(temp, "%x", gy_dec);

	BN_hex2bn(&yg, temp);
	cout << "y:" << temp << endl;
	memset(temp, 0, 256);

	//exit(0);

	int    iRet = EC_POINT_set_affine_coordinates(*group, G, xg, yg, *ctx);

	BIGNUM* cofactor = BN_new();
	BN_hex2bn(&cofactor, "1");

	iRet = EC_GROUP_set_generator(*group, G, order, cofactor);
	*outG = EC_POINT_new(*group);



	EC_POINT_copy(*outG, G);
	BN_copy(*outOrder, order);

	EC_POINT_free(G);
	BN_free(xg);
	BN_free(yg);
	BN_free(order);
	BN_free(cofactor);





	return iRet;

}

int  setECC4(BN_CTX** ctx, EC_GROUP** group, BIGNUM** p, BIGNUM** a, BIGNUM** b, EC_POINT** outG, BIGNUM** outOrder) {

	cout << "P:" << endl;
	int p_dec, a_dec, b_dec, gx_dec, gy_dec, order_dec;
	cin >> p_dec;
	cout << "a:" << endl;
	cin >> a_dec;
	cout << "b:" << endl;
	cin >> b_dec;
	cout << "x:" << endl;
	cin >> gx_dec;
	cout << "y:" << endl;
	cin >> gy_dec;
	cout << "order:" << endl;
	cin >> order_dec;

	char temp[256] = { 0 };
	sprintf(temp, "%x", p_dec);

	BN_hex2bn(p, temp);
	cout << "P:" << temp << endl;
	memset(temp, 0, 256);
	sprintf(temp, "%x", a_dec);
	BN_hex2bn(a, temp);
	cout << "a:" << temp << endl;
	memset(temp, 0, 256);
	sprintf(temp, "%x", b_dec);
	BN_hex2bn(b, temp);
	cout << "b:" << temp << endl;
	memset(temp, 0, 256);
	//BN_hex2bn(p, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
	//BN_hex2bn(a, "0000000000000000000000000000000000000000000000000000000000000000");
	//BN_hex2bn(b, "0000000000000000000000000000000000000000000000000000000000000007");

	*group = EC_GROUP_new_curve_GFp(*p, *a, *b, *ctx);
	//设置G点
	EC_POINT* G = EC_POINT_new(*group);

	BIGNUM* xg = BN_new();
	BIGNUM* yg = BN_new();
	BIGNUM* order = BN_new();

	sprintf(temp, "%x", order_dec);
	BN_hex2bn(&order, temp);
	cout << "order:" << temp << endl;
	memset(temp, 0, 256);

	sprintf(temp, "%x", gx_dec);
	BN_hex2bn(&xg, temp);
	cout << "x:" << temp << endl;
	memset(temp, 0, 256);
	sprintf(temp, "%x", gy_dec);

	BN_hex2bn(&yg, temp);
	cout << "y:" << temp << endl;
	memset(temp, 0, 256);

	//exit(0);

	int    iRet = EC_POINT_set_affine_coordinates(*group, G, xg, yg, *ctx);

	BIGNUM* cofactor = BN_new();
	BN_hex2bn(&cofactor, "1");

	iRet = EC_GROUP_set_generator(*group, G, order, cofactor);
	*outG = EC_POINT_new(*group);



	EC_POINT_copy(*outG, G);
	BN_copy(*outOrder, order);

	EC_POINT_free(G);
	BN_free(xg);
	BN_free(yg);
	BN_free(order);
	BN_free(cofactor);





	return iRet;

}

//int  setECC(BN_CTX** ctx, EC_GROUP** group, BIGNUM** p, BIGNUM** a, BIGNUM** b, EC_POINT** outG, BIGNUM** outOrder) {
//
//	setECC1(ctx, group, p, a, b, outG,outOrder);
//
//}
void RAPSIUtilOpenSSL::setEcc() {
	if (g_curve_params != NULL) {
		printf("setEcc 已初始化\n");
		return;
	}

	BN_CTX* ctx = BN_CTX_new();
	//    EC_GROUP *group = EC_GROUP_new_by_curve_name(NID_sm2);
	EC_GROUP* group;// = EC_GROUP_new_by_curve_name(NID_sm2);


	BIGNUM* p = BN_new();
	BIGNUM* a = BN_new();
	BIGNUM* b = BN_new();
	//    EC_POINT *G = EC_POINT_new(group);
	EC_POINT* G;//= EC_POINT_new(group);

	BIGNUM* order = BN_new();
	setECC(&ctx, &group, &p, &a, &b, &G, &order);

	g_curve_params = (CurveParams*)malloc(sizeof(CurveParams));
	g_curve_params->p = p;
	g_curve_params->a = a;
	g_curve_params->b = b;
	g_curve_params->group = group;
	g_curve_params->G = G;
	g_curve_params->order = order;

	BN_CTX_free(ctx);


}


void RAPSIUtilOpenSSL::sm3Hash(char* data, char* hash) {
	raHashSM3(data, (int)strlen(data), hash);

}
void RAPSIUtilOpenSSL::getInverseRA(char* ra, char* ra_1) {

	BN_CTX* ctx = BN_CTX_new();
	BIGNUM* rb = BN_new();
	BIGNUM* rb_1 = BN_new();

	BN_hex2bn(&rb, ra);
	BN_mod_inverse(rb_1, rb, g_curve_params->order, ctx);
	char* resutl = BN_bn2hex(rb_1);
	strcpy(ra_1, resutl);


	strcpy(ra, "");

	BN_CTX_free(ctx);
	BN_free(rb);
	BN_free(rb_1);
	OPENSSL_free(resutl);


}
void RAPSIUtilOpenSSL::pointBlindRA(char* point, char* ra, char* blindPoint) {

	BN_CTX* ctx = BN_CTX_new();
	BIGNUM* n = BN_new();
	int ret = BN_hex2bn(&n, ra);

	EC_POINT* pointa = EC_POINT_new(g_curve_params->group);
	EC_POINT* blind_pointa = EC_POINT_new(g_curve_params->group);

	EC_POINT_hex2point(g_curve_params->group, point, pointa, ctx);


	ret = EC_POINT_mul(g_curve_params->group, blind_pointa, NULL, pointa, n, ctx);
	if (ret == 1) {
		//        printf("EC_POINT_mul success \n");


		//        RAPonintCompressType
		char* result = EC_POINT_point2hex(g_curve_params->group, blind_pointa, POINT_CONVERSION_UNCOMPRESSED, ctx);
		strcpy(blindPoint, result);

		OPENSSL_free(result);
	}

	strcpy(point, "");
	strcpy(ra, "");

	BN_CTX_free(ctx);
	BN_free(n);
	EC_POINT_free(pointa);
	EC_POINT_free(blind_pointa);



}

void ComputeYSquare(const BIGNUM* x, CurveParams* curve_params_, BIGNUM** out_y2) {
	//    计算 y^2 = x^3 + a*x + b

	BN_CTX* ctx = BN_CTX_new();
	BIGNUM* x3 = BN_new();
	BIGNUM* x1 = BN_new();
	//    BIGNUM *x0 = BN_new();
	BIGNUM* x0;
	BIGNUM* y2 = BN_new();
	BIGNUM* tmp = BN_new();

	BN_hex2bn(&tmp, "3");

	int ret = BN_exp(x3, x, tmp, ctx);
	if (ret == 0) {
		printf("error \n");
	}
	ret = BN_mul(x1, x, curve_params_->a, ctx);
	x0 = curve_params_->b;
	ret = BN_add(y2, x3, x1);
	ret = BN_add(y2, y2, x0);

	BIGNUM* result = BN_new();
	BN_mod(result, y2, curve_params_->p, ctx);
	BN_copy(*out_y2, result);

	BN_free(x3);
	BN_free(x1);
	//    BN_free(x0);
	BN_free(y2);
	BN_free(tmp);
	BN_free(result);
	BN_CTX_free(ctx);

}
int isSqure(BIGNUM* y2, CurveParams* curve_params) {
	//    判断y2是否有平方根， y2 exp ((p - 1)/2) mod p == 1
	BN_CTX* ctx = BN_CTX_new();
	BIGNUM* sub1 = BN_new();
	BIGNUM* subRes = BN_new();
	BN_hex2bn(&sub1, "1");
	BN_sub(subRes, curve_params->p, sub1);

	BIGNUM* div1 = BN_new();
	BIGNUM* divRes = BN_new();
	BN_hex2bn(&div1, "2");
	BN_div(divRes, NULL, subRes, div1, ctx);



	BIGNUM* expRes = BN_new();
	//    BN_exp(expRes, y2, divRes, ctx);
	int ret = BN_mod_exp(expRes, y2, divRes, curve_params->p, ctx);
	ret = BN_is_one(expRes);


	BN_CTX_free(ctx);
	BN_free(sub1);
	BN_free(subRes);
	BN_free(div1);
	BN_free(divRes);
	BN_free(expRes);



	return ret;

}

void makeList() {

	cout << "makeList" << endl;


	BN_CTX* ctx = BN_CTX_new();
	BIGNUM* n = BN_new();
	const char* ra = "1";


	int ret;

	char blindPoint[1024] = { 0 };
	EC_POINT* pointa = EC_POINT_new(g_curve_params->group);
	EC_POINT* blind_pointa = EC_POINT_new(g_curve_params->group);

	//EC_POINT_hex2point(g_curve_params->group, point, pointa, ctx);



	int i = 0;
	int count = 1000;
	while (true)
	{
		char temp[256] = { 0 };
		sprintf(temp, "%x", i);

		ret = BN_hex2bn(&n, temp);
		ret = EC_POINT_mul(g_curve_params->group, blind_pointa, NULL, g_curve_params->G, n, ctx);
		if (ret == 1) {
			//POINT_CONVERSION_UNCOMPRESSED   POINT_CONVERSION_COMPRESSED  POINT_CONVERSION_HYBRID
			char* result = EC_POINT_point2hex(g_curve_params->group, blind_pointa, POINT_CONVERSION_UNCOMPRESSED, ctx);
			cout << temp << "	|	" << result << endl;
			OPENSSL_free(result);



		}
		i++;
		if (i >= count)
		{
			break;

		}

	}


	BN_CTX_free(ctx);
	BN_free(n);
	EC_POINT_free(pointa);
	EC_POINT_free(blind_pointa);


}
void mulityPoint(char* factor, char* point, char** ourRes) {
	//char temp[256] = "1b";
	char* temp = factor;



	BIGNUM* n = BN_new();

	BN_CTX* ctx = BN_CTX_new();

	int ret;
	EC_POINT* blind_pointa = EC_POINT_new(g_curve_params->group);
	EC_POINT* pointPP = EC_POINT_new(g_curve_params->group);
	EC_POINT_hex2point(g_curve_params->group, point, pointPP, ctx);
	ret = BN_hex2bn(&n, temp);


	ret = EC_P